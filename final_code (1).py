# -*- coding: utf-8 -*-
"""FINAL_CODE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14erqTU_qwjvmWlPXza_2902pZUS3P8Bo
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
#!apt-get install texlive-full
## reset defaults
#plt.rcdefaults()

## Set up LaTeX fonts
#plt.rcParams.update({
#    "text.usetex": True,
#    "font.family": "serif",
#    "font.serif": ["Computer Modern Roman"],
#    "font.size": 14,
#    })
from mpl_toolkits.mplot3d import Axes3D
mpl.rcParams['text.usetex'] = False  # Ensure LaTeX is not required

# Define time parameters
T = 0.497

# Dimensions
road_length =L= 2.0  # in km
road_width =W= 0.0075  # in km

# Number of grid cells
nx = 100   # along the length of the road
ny = 10 # along the width of the road

# Spatial step sizes
dx = road_length / nx  # spatial step size in km along the length
dy = road_width / ny   # spatial step size in km along the width

# Define constants
#W =0.0075  # Width of the road in km
r_i = {'A': 0.89, 'B': 0.78, 'C': 0.74, 'D': 0.50}
D_A, D_B, D_C, D_D = 0.0000006, 0.0000005, 0.0000004, 0.0000003  # Diffusion coefficients in km^2/h
a_A, a_B, a_C, a_D = 0.0018 * 0.0006, 0.0026 * 0.0014, 0.004 * 0.0016, 0.0065 * 0.0022
# Maximum AO values for each class
AO_max_A, AO_max_B, AO_max_C, AO_max_D = 0.80, 0.78, 0.68, 0.50
AO_max=0.8
# Initialize densities with random values

np.random.seed(0)  # For reproducibility


epsilon = 1e-5

# Target average densities for the different regions
target_density_A = 10
target_density_B = 10
target_density_C = 5
target_density_D = 4

def generate_uniform_density(target_density, shape):#Instead of generating random numbers, we now use np.full to create an array of the given shape filled with the target_density. This directly creates a uniform distribution where all values are equal to the target density.
    """Generates a uniform density field with a specified target density.

    Args:

        target_density: The desired average density.
        shape: The shape of the density field (e.g., (nx, ny)).

    Returns:
        A NumPy array containing the uniform density field.
    """
    uniform_density = np.full(shape, target_density)
    return uniform_density
# Initialize densities with uniform distribution
rho_A = generate_uniform_density(target_density_A, (nx, ny))
rho_B = generate_uniform_density(target_density_B, (nx, ny))
rho_C = generate_uniform_density(target_density_C, (nx, ny))
rho_D = generate_uniform_density(target_density_D, (nx, ny))

# Target average velocities (in km/h)
u_target_A_x, u_target_A_y = 45.0, 2.5
u_target_B_x, u_target_B_y = 42.1, 1.4
u_target_C_x, u_target_C_y = 52.9, 5.6
u_target_D_x, u_target_D_y = 47.2, 4.3
def generate_uniform_velocity(target_velocity_x, target_velocity_y, shape):
    """Generates a uniform velocity field with specified target velocities.

    Args:
        target_velocity_x: The desired average velocity in the x-direction.
        target_velocity_y: The desired average velocity in the y-direction.
        shape: The shape of the velocity field (e.g., (nx, ny)).

    Returns:
        A tuple containing two NumPy arrays:
            - u_x: Uniform velocity field in the x-direction.
            - u_y: Uniform velocity field in the y-direction.
    """
    u_x = np.full(shape, target_velocity_x)
    u_y = np.full(shape, target_velocity_y)
    return u_x, u_y
# Initialize velocity fields with uniform distribution
u_x_A, u_y_A = generate_uniform_velocity(u_target_A_x, u_target_A_y, (nx, ny))
u_x_B, u_y_B = generate_uniform_velocity(u_target_B_x, u_target_B_y, (nx, ny))
u_x_C, u_y_C = generate_uniform_velocity(u_target_C_x, u_target_C_y, (nx, ny))
u_x_D, u_y_D = generate_uniform_velocity(u_target_D_x, u_target_D_y, (nx, ny))

# Calculate flow (Q) directly from density (rho) and velocity (v)
Q_x_A = rho_A * u_x_A
Q_y_A = rho_A * u_y_A
Q_x_B = rho_B * u_x_B
Q_y_B = rho_B * u_y_B
Q_x_C = rho_C * u_x_C
Q_y_C = rho_C * u_y_C
Q_x_D = rho_D * u_x_D
Q_y_D = rho_D * u_y_D

# Initialize AO matrix
AO = a_A * rho_A + a_B * rho_B + a_C * rho_C + a_D * rho_D

# Define inflow values (vehicles per hour)
q_A_inflow = 5
q_B_inflow = 4
q_C_inflow = 3
q_D_inflow = 2

"""See where the following code is used."""

# Determine maximum velocities
u_x_max = max(np.max(u_x_A), np.max(u_x_B), np.max(u_x_C), np.max(u_x_D))
u_y_max = max(np.max(u_y_A), np.max(u_y_B), np.max(u_y_C), np.max(u_y_D))

# Determine maximum diffusion coefficient
D_max = max(D_A, D_B, D_C, D_D)

"""See if the cfl condition mentioned here is correct cite a paper in your document"""

# Calculate the time step to satisfy CFL conditions
dt_advection_x = dx / u_x_max
dt_advection_y = dy / u_y_max
dt_diffusion_x = dx**2 / (2 * D_max)
dt_diffusion_y = dy**2 / (2 * D_max)

# Choose the smaller time step to ensure all conditions are satisfied
dt = min(dt_advection_x, dt_advection_y, dt_diffusion_x, dt_diffusion_y)

"""See how the following code is used"""



# Calculate number of time steps
time_steps = int(T/dt)
time = np.linspace(0, T, time_steps)

# Define stopping and starting intervals in seconds
stop_interval = 35 / 3600  # Interval in hours (35 seconds)
start_interval = 70 / 3600  # Interval in hours (70 seconds)
stop_position = 1
def is_stopping(t, stop_interval=stop_interval, start_interval=start_interval):
    """Checks if the current time is within a stopping interval."""
    cycle_duration = stop_interval + start_interval  # Total duration of one stop-start cycle
    time_in_cycle = t % cycle_duration  # Time elapsed within the current cycle

    if 0 <= time_in_cycle < stop_interval:
        return True  # Stopping is active
    else:
        return False  # Stopping is inactive
#is_stopping(105/3600)



def apply_stopping_behavior_u(u_x, u_y, t):
    if is_stopping(t): #if is stopping function is true
        stopping_region = (np.arange(nx) * dx == stop_position)
        u_x[stopping_region, :] = 0
        u_y[stopping_region, :] = 0
    return u_x, u_y
#np.arange(nx):Creates an array of integers from 0 to nx - 1.
# In this model, velocity is updated based on a predefined equation involving density and maximum velocity. It's treated more as an input to the system influencing the flow, while flow is the variable being calculated and updated using the numerical scheme. so velocity is defined using single variable
def apply_stopping_behavior_f(Q_updated_x, Q_updated_y, t):
    if is_stopping(t): #if is stopping function is true
        stopping_region = (np.arange(nx) * dx == stop_position)
        Q_updated_x[stopping_region, :] = 0
        Q_updated_y[stopping_region, :] = 0
    return Q_updated_x, Q_updated_y
# Create some test data:
test_u_x = np.ones((nx, ny))  # Initialize with all values as 1
test_u_y = np.ones((nx, ny))  # Initialize with all values as 1
test_Q_x = np.ones((nx, ny))  # Initialize with all values as 1
test_Q_y = np.ones((nx, ny))  # Initialize with all values as 1

# Define a test time within a stopping interval:
test_time_stopping = 106/3600  # For example, half of the stop_interval

# Apply the stopping behavior functions:
modified_u_x, modified_u_y = apply_stopping_behavior_u(test_u_x, test_u_y, test_time_stopping)


# Check if values are 0 in the stopping region:
stopping_region = (np.arange(nx) * dx == stop_position)

# For velocity:
if np.all(modified_u_x[stopping_region, :] == 0) and np.all(modified_u_y[stopping_region, :] == 0):
    print("Stopping behavior for velocity applied correctly.")
else:
    print("Error: Stopping behavior for velocity not applied correctly.")

# Function to calculate fluxes using upwind scheme in FVM
def calculate_fluxes_upwind(Q_x, Q_y,AO, AO_minus,a, u_x, u_y, D, dx, dy, q_inflow,t):
    u_x = np.abs(u_x)
    u_y = np.abs(u_y)

    # Initialize fluxes with Q values
    Q_updated_x = Q_x.copy()  # Use the provided Q_x as the initial flux_x
    Q_updated_y = Q_y.copy()  # Use the provided Q_y as the initial flux_y
    # Distribute inflow uniformly to all rows at the left boundary (x=0)
    if t <= 15/60:  # Inflow for the first 15 minutes
        inflow = q_inflow
    else:
        inflow = 0  # No inflow after 15 minutes

    """# Replace denominators that are zero or close to zero with epsilon
    #dx_safe = np.where((np.isclose(dx,0)), epsilon, dx)
    #dy_safe = np.where((np.isclose(dy,0)), epsilon, dy)
    a_safe = np.where((np.isclose(a,0)), epsilon, a)

    # Replace denominators that are zero or close to zero with epsilon
    dx_safe = np.where(dx == 0, epsilon, dx)
    dy_safe = np.where(dy == 0, epsilon, dy)
    a_safe = np.where(a == 0, epsilon, a)"""

    for i in range(1, Q_x.shape[0]-1):
        for j in range(Q_x.shape[1]):
            if i==1:
                Q_updated_x[i,j] = inflow/dy

            else:
                Q_updated_x[i, j]=(1/a)*(u_x[i, j] *(AO[i, j] - AO_minus[i, j]) )-(D/a)*(((AO[i+1, j] - AO_minus[i+1, j]) - (AO[i-1, j] - AO_minus[i-1, j])) / (2*(dx + epsilon)))#Using central difference scheme for derivatives
                Q_updated_x[i,j]=max(0,Q_updated_x[i,j])
    # Compute fluxes in the y direction
    for i in range(Q_y.shape[0]-1):
        for j in range(1, Q_y.shape[1]):
            if i==1:
              Q_updated_y[i,j] = inflow/dx

            elif j==1:
                Q_updated_y[i,j] = 0
            elif j == ny-1:
                Q_updated_y[i,j] = 0
            else:
                Q_updated_y[i,j]= (1/a)*(u_y[i, j] *(AO[i, j] - AO_minus[i, j]) )-(D/a)*(((AO[i, j+1] - AO_minus[i, j+1]) - (AO[i, j-1] - AO_minus[i, j-1])) / (2*(dy + epsilon)))
                Q_updated_y[i,j]=max(epsilon,Q_updated_y[i,j])
    return Q_updated_x, Q_updated_y, np.sqrt(Q_updated_x**2 + Q_updated_y**2),inflow
"see before eqn 20 of the last report for the eqn"

def update_density_fvm(rho,AO, AO_minus,a, u_x, u_y, D, q_inflow, dx, dy,Q_x, Q_y, dt,t):
    #inflow density at the boundary is calculated as the total number of vehicles entering per unit time, distributed uniformly across the width of the road.
    nx, ny = rho.shape
    rho_new = rho.copy()
    Q_updated_x, Q_updated_y, Q , _= calculate_fluxes_upwind(Q_x, Q_y,AO, AO_minus,a, u_x, u_y, D, dx, dy, q_inflow,t)

    # Update density using finite volume method
    for i in range(1, nx-1):
        for j in range(1, ny-1):
          if i==nx-1:
            rho_new[i, j]=0
          else:
            rho_new[i, j] = rho[i, j] - (dt/(2*dx)) * (Q_updated_x[i+1,j] - Q_updated_x[i-1,j]) - (dt/(2*dy)) * (Q_updated_y[i+1,j] - Q_updated_y[i-1,j])
            # Ensure densities remain non-negative
            rho_new[i, j] = np.maximum(rho_new[i, j], 0.00000000001)
    return rho_new

# Define a tolerance for floating-point comparisons
tolerance = 1e-5
plotted_times = set()

# Time-stepping loop
time_points = np.linspace(0, T,100 ) # To visualize at 10 points in time
time_index = 0

# Specify the location for velocity extraction
x_loc = 0.95  # km
y_loc = road_width / 2  # km

# Find the nearest grid indices to the specified location
x_index = int(round(x_loc / dx))
y_index = int(round(y_loc / dy))
inflow_A_time = []  # List to store inflow values for class A over time
inflow_B_time = []  # List to store inflow values for class B over time
inflow_C_time = []  # List to store inflow values for class C over time
inflow_D_time = []
# Initialize a list to store AO values over time
AO_time = []
AO_time_x = []
AO_time_y = []
AO_x_y=[]
# Extract velocities over time at the specified location
v_A_time = []
v_B_time = []
v_C_time = []
v_D_time = []
uy_A_time = []
uy_B_time = []
uy_C_time = []
uy_D_time = []
flow_A_time = []  # List to store inflow values for class A over time
flow_B_time = []  # List to store inflow values for class B over time
flow_C_time = []  # List to store inflow values for class C over time
flow_D_time = []
time_list=[]

def limit_AO(AO):
    """Limits AO values to the range [0.018, 0.8].

    Args:
        AO: A NumPy array containing AO values.

    Returns:
        A NumPy array with AO values limited to the specified range.
    """
    AO_limited = AO.copy()  # Create a copy of AO to avoid modifying the original array
    for i in range(AO.shape[0]):
        for j in range(AO.shape[1]):
            if AO_limited[i, j] < 0.018:
                AO_limited[i, j] = 0.018
            elif AO_limited[i, j] > 0.8:
                AO_limited[i, j] = 0.8
            else:
              AO_limited[i, j] = AO_limited[i, j]

    return AO_limited

def limit_densities(rho,rho_T,a, AO, AO_max, epsilon=1e-5):
    """
    Limits densities according to the formula rho_i' = rho_i - (rho_i / AO) * (AO - AO_max)
    if AO exceeds AO_max.

    Args:
        rho: The current density array for a specific class.
        AO: The current overall AO value (or array).
        AO_max: The maximum allowed AO value for the specific class.
        epsilon: A small value to prevent division by zero.

    Returns:
        A NumPy array containing the limited densities.
    """
    rho_limited = rho.copy()  # Create a copy to avoid modifying the original array
    # Apply the limiting formula only where AO > AO_max
    # Use epsilon to avoid division by zero if AO is close to zero
    mask = AO > AO_max #mask is just a single boolean (True or False). If AO > AO_max, all densities would be reduced
    # Apply the limiting formula only where the mask is True epsil
    #rho_limited[mask] = rho_limited[mask] - (rho_limited[mask] / (rho_T[mask] +epsilon)) * (AO[mask] - AO_max)
    #rho_limited[mask]=((rho_limited[mask]))*((AO_max)/(AO[mask]+epsilon))
    rho_limited[mask]=(AO_max/(a+epsilon))*(rho[mask]/(rho_T[mask]+epsilon))
    return rho_limited



# Time-stepping loop
for t in time:
     # Recalculate AO
    rho_T=rho_A+rho_B+rho_C+rho_D
    AO = a_A * rho_A + a_B * rho_B + a_C * rho_C + a_D * rho_D
    #AO_A= a_A * rho_A
    #AO_B= a_B * rho_B
    #AO_C= a_C * rho_C
    #AO_D= a_D * rho_D
    rho_A = limit_densities(rho_A,rho_T,a_A, AO, AO_max)
    rho_B = limit_densities(rho_B,rho_T,a_B, AO, AO_max)
    rho_C = limit_densities(rho_C,rho_T,a_C, AO, AO_max)
    rho_D = limit_densities(rho_D,rho_T,a_D, AO, AO_max)
    AO = a_A * rho_A + a_B * rho_B + a_C * rho_C + a_D * rho_D
    AO=limit_AO(AO)
    AO_time.append(AO[x_index, y_index])
    AO_time_x.append(AO[:, y_index])
    AO_time_y.append(AO[x_index,:])


     # Calculate AO_minus for each category
    AO_minus_A = AO - a_A * rho_A
    AO_minus_B = AO - a_B * rho_B
    AO_minus_C = AO - a_C * rho_C
    AO_minus_D = AO - a_D * rho_D
    Q_x_A, Q_y_A, Q_A,inflow_A = calculate_fluxes_upwind( Q_x_A, Q_y_A,AO, AO_minus_A, a_A, u_x_A, u_y_A, D_A, dx, dy, q_A_inflow,t) # Pass q_A_inflow
    Q_x_B, Q_y_B, Q_B,inflow_B = calculate_fluxes_upwind(Q_x_B, Q_y_B,AO, AO_minus_B,a_B, u_x_B, u_y_B, D_B, dx, dy, q_B_inflow,t) # Pass q_B_inflow
    Q_x_C, Q_y_C, Q_C,inflow_C = calculate_fluxes_upwind(Q_x_C, Q_y_C,AO, AO_minus_C,a_C, u_x_C, u_y_C, D_C, dx, dy, q_C_inflow,t) # Pass q_C_inflow
    Q_x_D, Q_y_D, Q_D,inflow_D = calculate_fluxes_upwind(Q_x_D, Q_y_D,AO, AO_minus_D,a_D, u_x_D, u_y_D, D_D, dx, dy, q_D_inflow,t) # Pass q_D_inflow

    Q_x_A, Q_y_A = apply_stopping_behavior_f(Q_x_A, Q_y_A, t)
    Q_x_B, Q_y_B = apply_stopping_behavior_f(Q_x_B, Q_y_B, t)
    Q_x_C, Q_y_C = apply_stopping_behavior_f(Q_x_C, Q_y_C, t)
    Q_x_D, Q_y_D = apply_stopping_behavior_f(Q_x_D, Q_y_D, t)



    # Update densities using FVM with upwind scheme
    # Update densities using FVM with upwind scheme
    rho_A = update_density_fvm(rho_A, AO, AO_minus_A, a_A, u_x_A, u_y_A, D_A, q_A_inflow, dx, dy, Q_x_A, Q_y_A, dt,t)
    rho_B = update_density_fvm(rho_B,AO, AO_minus_B, a_B,  u_x_B, u_y_B, D_B, q_B_inflow, dx, dy, Q_x_B, Q_y_B, dt,t)
    rho_C = update_density_fvm(rho_C,AO, AO_minus_C, a_C,  u_x_C, u_y_C, D_C, q_C_inflow, dx, dy, Q_x_C, Q_y_C, dt,t)
    rho_D = update_density_fvm(rho_D, AO, AO_minus_D, a_D,  u_x_D, u_y_D, D_D, q_D_inflow, dx, dy, Q_x_D, Q_y_D, dt,t)
    # Recalculate AO





    # Update velocities
    u_x_A = u_target_A_x * (1 - np.exp(1 - np.exp(r_i['A'] *( AO_max_A / (AO+epsilon)) - r_i['A'])))
    u_y_A = u_target_A_y * (1 - np.exp(1 - np.exp(r_i['A'] * (AO_max_A / (AO+epsilon)) - r_i['A'])))
    u_x_B = u_target_B_x * (1 - np.exp(1 - np.exp(r_i['B'] * (AO_max_B / (AO+epsilon)) - r_i['B'])))
    u_y_B = u_target_B_y * (1 - np.exp(1 - np.exp(r_i['B'] * (AO_max_B / (AO+epsilon)) - r_i['B'])))
    u_x_C = u_target_C_x * (1 - np.exp(1 - np.exp(r_i['C'] * (AO_max_C / (AO+epsilon)) - r_i['C'])))
    u_y_C = u_target_C_y * (1 - np.exp(1 - np.exp(r_i['C'] * (AO_max_C / (AO+epsilon)) - r_i['C'])))
    u_x_D = u_target_D_x * (1 - np.exp(1 - np.exp(r_i['D'] * (AO_max_D / (AO+epsilon)) - r_i['D'])))
    u_y_D = u_target_D_y * (1 - np.exp(1 - np.exp(r_i['D'] * (AO_max_D / (AO+epsilon)) - r_i['D'])))


    # Apply stopping behavior
    u_x_A, u_y_A = apply_stopping_behavior_u(u_x_A, u_y_A, t)
    u_x_B, u_y_B = apply_stopping_behavior_u(u_x_B, u_y_B, t)
    u_x_C, u_y_C = apply_stopping_behavior_u(u_x_C, u_y_C, t)
    u_x_D, u_y_D = apply_stopping_behavior_u(u_x_D, u_y_D, t)


    #Excluding negative velocities

    u_x_A = np.maximum(u_x_A, 0)
    u_y_A = np.maximum(u_y_A, 0)
    u_x_B = np.maximum(u_x_B, 0)
    u_y_B = np.maximum(u_y_B, 0)
    u_x_C = np.maximum(u_x_C, 0)
    u_y_C = np.maximum(u_y_C, 0)
    u_x_D = np.maximum(u_x_D, 0)
    u_y_D = np.maximum(u_y_D, 0)





    # Update densities using FVM with upwind scheme








    # Calculate velocity magnitudes
    v_A = np.sqrt(u_x_A**2 + u_y_A**2)
    v_B = np.sqrt(u_x_B**2 + u_y_B**2)
    v_C = np.sqrt(u_x_C**2 + u_y_C**2)
    v_D = np.sqrt(u_x_D**2 + u_y_D**2)
    #flow
    flow_A = v_A*rho_A
    flow_B = v_B*rho_B
    flow_C = v_C*rho_C
    flow_D = v_D*rho_D
    # Append velocities to the lists
    v_A_time.append(np.sqrt(u_x_A[x_index, y_index]**2 + u_y_A[x_index, y_index]**2))
    v_B_time.append(np.sqrt(u_x_B[x_index, y_index]**2 + u_y_B[x_index, y_index]**2))
    v_C_time.append(np.sqrt(u_x_C[x_index, y_index]**2 + u_y_C[x_index, y_index]**2))
    v_D_time.append(np.sqrt(u_x_D[x_index, y_index]**2 + u_y_D[x_index, y_index]**2))

    #Append the lateral velocities
    # Append velocities to the lists
    uy_A_time.append(u_y_A[x_index, y_index])
    uy_B_time.append(u_y_B[x_index, y_index])
    uy_C_time.append(u_y_C[x_index, y_index])
    uy_D_time.append(u_y_D[x_index, y_index])

    time_list.append(t)
    inflow_A_time.append(inflow_A)  # Append the inflow value for class A
    inflow_B_time.append(inflow_B)  # Append the inflow value for class B
    inflow_C_time.append(inflow_C)  # Append the inflow value for class C
    inflow_D_time.append(inflow_D)
    flow_A_time.append(flow_A[x_index, y_index])  # Append the inflow value for class A
    flow_B_time.append(flow_B[x_index, y_index])  # Append the inflow value for class B
    flow_C_time.append(flow_C[x_index, y_index])  # Append the inflow value for class C
    flow_D_time.append(flow_D[x_index, y_index])

    closest_time = min(time_points, key=lambda tp: abs(t - tp))#line is used to find the closest time point from time_points to the current simulation time t
  # Generate 3D contour plots only at specified time points
    if (abs(t - closest_time) < tolerance and closest_time not in plotted_times and (closest_time == 0 or closest_time == T or abs(t - closest_time) < tolerance)):
        plotted_times.add(closest_time)
        #A plot is generated only if t is close to one of the time_points (accounting for floating-point precision).
#Each time_point is plotted only once.
#Special cases (start at t=0 and end at t=T) are always handled explicitly and accurately.

        X, Y = np.meshgrid(np.arange(nx) * dx, np.arange(ny) * dy)
  # Generate 3D contour plots only at specified time points
    #if any(np.abs(t - tp) < tolerance for tp in time_points):
       # X, Y = np.meshgrid(np.arange(nx) * dx, np.arange(ny) * dy)

        # Create a new figure for each time step
        fig = plt.figure(figsize=(24, 18))
        fig.suptitle(f'Time: {closest_time:.2f} hours')  # Update the title with the current time

        # Density plots
        ax1 = fig.add_subplot(3, 4, 1, projection='3d')
        surf1 = ax1.plot_surface(X, Y, rho_A.T, cmap='viridis')
        ax1.set_title('Density A(Veh/km^2)')
        ax1.set_xlabel('X-axis (km)')
        ax1.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=10)
        cbar.set_label(' Density (A)(Veh/km^2)', fontsize=12)

        ax2 = fig.add_subplot(3, 4, 2, projection='3d')
        surf2 = ax2.plot_surface(X, Y, rho_B.T, cmap='viridis')
        ax2.set_title('Density B(Veh/km^2)')
        ax2.set_xlabel('X-axis (km)')
        ax2.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=10)
        cbar.set_label(' Density (B)(Veh/km^2)', fontsize=12)

        ax3 = fig.add_subplot(3, 4, 3, projection='3d')
        surf3 = ax3.plot_surface(X, Y, rho_C.T, cmap='viridis')
        ax3.set_title('Density C(Veh/km^2)')
        ax3.set_xlabel('X-axis(km)')
        ax3.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf3, ax=ax3, shrink=0.5, aspect=10)
        cbar.set_label(' Density (C)(Veh/km^2)', fontsize=12)

        ax4 = fig.add_subplot(3, 4, 4, projection='3d')
        surf4 = ax4.plot_surface(X, Y, rho_D.T, cmap='viridis')
        ax4.set_title('Density D(Veh/km^2)')
        ax4.set_xlabel('X-axis(km)')
        ax4.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf4, ax=ax4, shrink=0.5, aspect=10)
        cbar.set_label(' Density (D)(Veh/km^2)', fontsize=12)

        # Velocity magnitude plots
        ax5 = fig.add_subplot(3, 4, 5, projection='3d')
        surf5 = ax5.plot_surface(X, Y, v_A.T, cmap='magma')
        ax5.set_title('Velocity Magnitude A (km/hr) ')
        ax5.set_xlabel('X-axis(km)')
        ax5.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf5, ax=ax5, shrink=0.5, aspect=10)
        cbar.set_label('Velocity Magnitude A (km/hr) ', fontsize=12)

        ax6 = fig.add_subplot(3, 4, 6, projection='3d')
        surf6 = ax6.plot_surface(X, Y, v_B.T, cmap='magma')
        ax6.set_title('Velocity Magnitude B (km/hr) ')
        ax6.set_xlabel('X-axis(km)')
        ax6.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf6, ax=ax6, shrink=0.5, aspect=10)
        cbar.set_label('Velocity Magnitude B (km/hr) ', fontsize=12)

        ax7 = fig.add_subplot(3, 4, 7, projection='3d')
        surf7 = ax7.plot_surface(X, Y, v_C.T, cmap='magma')
        ax7.set_title('Velocity Magnitude C (km/hr) ')
        ax7.set_xlabel('X-axis(km)')
        ax7.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf7, ax=ax7, shrink=0.5, aspect=10)
        cbar.set_label('Velocity Magnitude C (km/hr) ', fontsize=12)

        ax8 = fig.add_subplot(3, 4, 8, projection='3d')
        surf8 = ax8.plot_surface(X, Y, v_D.T, cmap='magma')
        ax8.set_title('Velocity Magnitude D (km/hr) ')
        ax8.set_xlabel('X-axis(km)')
        ax8.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf8, ax=ax8, shrink=0.5, aspect=10)
        cbar.set_label('Velocity Magnitude D (km/hr) ', fontsize=12)

        # Flow plots
        # Flow plots (modified)
        ax9 = fig.add_subplot(3, 4, 9, projection='3d')
        surf9 = ax9.plot_surface(X, Y, flow_A.T, cmap='plasma') # Changed Q_A to flow_A
        ax9.set_title('Flow per length_A (veh/kmhr)') # Changed title
        ax9.set_xlabel('X-axis(km)')
        ax9.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf9, ax=ax9, shrink=0.5, aspect=10)
        cbar.set_label('Flow per length_A (veh/kmhr)', fontsize=12) # Changed colorbar label

        ax10 = fig.add_subplot(3, 4, 10, projection='3d')
        surf10 = ax10.plot_surface(X, Y, flow_B.T, cmap='plasma') # Changed Q_B to flow_B
        ax10.set_title('Flow per length _B (veh/kmhr)') # Changed title
        ax10.set_xlabel('X-axis(km)')
        ax10.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf10, ax=ax10, shrink=0.5, aspect=10)
        cbar.set_label('Flow per length _B (veh/kmhr)', fontsize=12) # Changed colorbar label

        ax11 = fig.add_subplot(3, 4, 11, projection='3d')
        surf11 = ax11.plot_surface(X, Y, flow_C.T, cmap='plasma') # Changed Q_C to flow_C
        ax11.set_title('Flow per length_C (veh/kmhr)') # Changed title
        ax11.set_xlabel('X-axis(km)')
        ax11.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf11, ax=ax11, shrink=0.5, aspect=10)
        cbar.set_label('Flow per length_C (veh/kmhr)', fontsize=12) # Changed colorbar label

        ax12 = fig.add_subplot(3, 4, 12, projection='3d')
        surf12 = ax12.plot_surface(X, Y, flow_D.T, cmap='plasma') # Changed Q_D to flow_D
        ax12.set_title('Flow per length_D (veh/kmhr)') # Changed title
        ax12.set_xlabel('X-axis(km)')
        ax12.set_ylabel('Y-axis(km)')
        cbar = fig.colorbar(surf12, ax=ax12, shrink=0.5, aspect=10)
        cbar.set_label('Flow per length_D (veh/kmhr)', fontsize=12)
        # Check if stopping behavior is applied
        """
        stopping_applied_u_A = apply_stopping_behavior_u(u_x_A, u_y_A, t)
        stopping_applied_u_B = apply_stopping_behavior_u(u_x_B, u_y_B, t)
        stopping_applied_u_C = apply_stopping_behavior_u(u_x_C, u_y_C, t)
        stopping_applied_u_D = apply_stopping_behavior_u(u_x_D, u_y_D, t)

        stopping_applied_f_A = apply_stopping_behavior_f(Q_x_A, Q_y_A, t)
        stopping_applied_f_B = apply_stopping_behavior_f(Q_x_B, Q_y_B, t)
        stopping_applied_f_C = apply_stopping_behavior_f(Q_x_C, Q_y_C, t)
        stopping_applied_f_D = apply_stopping_behavior_f(Q_x_D, Q_y_D, t)"""


        #filename = f'density_velocity_flow_time_{closest_time:.2f}.svg'
        #fig.savefig(filename, format='svg')
        #plt.tight_layout()
        #plt.show()
        for i in range(1, 13):  # Iterate over all subplots
            ax = fig.axes[i - 1]  # Get the current axis
            cbar = ax.get_figure().get_axes()[-1]  # Get the colorbar for the current axis

            # Create ScalarFormatter for scientific notation with consistent format
            formatter = mpl.ticker.ScalarFormatter(useMathText=False)
            #formatter.set_scientific(True)  # Force scientific notation
            #formatter.set_powerlimits((-3, 3))  # Always use scientific notation

            # Adjust colorbar tick label spacing
            cbar.tick_params(axis='y', labelsize=10)
            # Apply the formatter to the colorbar axis
            cbar.yaxis.set_major_formatter(formatter)

            # Adjust colorbar tick label spacing and size
            cbar.tick_params(axis='y', labelsize=10)

        plt.tight_layout(rect=[0, 0, 1, 0.96])  # Adjust layout to prevent title overlap
        filename = f'density_velocity_flow_time_{closest_time:.2f}.svg'
        fig.savefig(filename, format='svg')
        plt.show()


    time_index = (time_index + 1) % len(time_points)  # Increment time_index only when plotting

# prompt: flow_time plot for all classes\

import matplotlib.pyplot as plt

# Assuming flow_A_time, flow_B_time, flow_C_time, flow_D_time, and time_list are defined
# from your previous code.

plt.figure(figsize=(10, 6))
plt.plot(time_list, flow_A_time, label='Class A')
plt.plot(time_list, flow_B_time, label='Class B')
plt.plot(time_list, flow_C_time, label='Class C')
plt.plot(time_list, flow_D_time, label='Class D')

plt.xlabel('Time (hours)')
plt.ylabel('Flow per length (veh/kmhr)')
plt.title(f'Flow per length vs time Plot for all classes at x = {x_loc} km, y = {y_loc} km')
plt.legend()
plt.grid(True)
plt.show()

"""
plt.plot(time_list, q_C_inflow_array, label='Class C')
plt.plot(time_list, q_D_inflow_array, label='Class D')
plt.xlabel('Time (hours)')
plt.ylabel('Inflow (veh/hr)')
plt.title(f'Inflow of vehicle classes with time ')
plt.grid(True)
plt.legend()
plt.show()"""
plt.figure(figsize=(10, 6))
plt.plot(time_list, inflow_A_time, label='Class A')
plt.plot(time_list, inflow_B_time, label='Class B')
plt.plot(time_list, inflow_C_time, label='Class C')
plt.plot(time_list, inflow_D_time, label='Class D')
plt.xlabel('Time (hours)')
plt.ylabel('Inflow (veh/hr)')
plt.title('Inflow of vehicle classes with time')
plt.grid(True)
plt.legend()
plt.show()

# Plotting the velocities
plt.figure(figsize=(10, 6))
plt.plot(time_list, v_A_time, label='Class A')
plt.plot(time_list, v_B_time, label='Class B')
plt.plot(time_list, v_C_time, label='Class C')
plt.plot(time_list, v_D_time, label='Class D')
plt.xlabel('Time (hours)')
plt.ylabel('Velocity (km/hr)')
plt.title(f'Velocity of Vehicle Classes at x = {x_loc} km, y = {y_loc} km')
plt.grid(True, linewidth=0.5)
plt.legend()
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(time_list, AO_time, label='AO')  # Assuming time_list is already defined
plt.xlabel('Time (hours)')
plt.ylabel('AO')
plt.title(f'AO over Time at x = {x_loc} km, y = {y_loc} km')
plt.grid(True)
plt.legend()
plt.show()



# Create meshgrids for plotting
X_plot, T_plot = np.meshgrid(np.arange(nx) * dx, time)
Y_plot, T_plot_y = np.meshgrid(np.arange(ny) * dy, time)
X, Y = np.meshgrid(np.arange(nx) * dx, np.arange(ny) * dy)
# Convert AO_time data to NumPy arrays
AO_time_x_array = np.array(AO_time_x)
AO_time_y_array = np.array(AO_time_y)
AO_x_y_array=np.array(AO_x_y)
# Create the figure with subplots
fig = plt.figure(figsize=(16, 6))

# First subplot: AO vs x and t
ax1 = fig.add_subplot(1, 2, 1, projection='3d')
surf1 = ax1.plot_surface(X_plot, T_plot, AO_time_x_array, cmap='viridis')
ax1.set_xlabel('X-axis (km)')
ax1.set_ylabel('Time (hours)')
ax1.set_zlabel('AO')
ax1.set_title('AO vs X and Time at y = 0.00375 km')
fig.colorbar(surf1, ax=ax1, shrink=0.5, aspect=10, label='AO')
#ax1.view_init(elev=90, azim=-90)
# Second subplot: AO vs y and t
ax2 = fig.add_subplot(1, 2, 2, projection='3d')
surf2 = ax2.plot_surface(Y_plot, T_plot_y, AO_time_y_array, cmap='viridis')
ax2.set_xlabel('Y-axis (km)')
ax2.set_ylabel('Time (hours)')
ax2.set_zlabel('AO')
ax2.set_title('AO vs Y and Time at x = 0.95 km')
fig.colorbar(surf2, ax=ax2, shrink=0.5, aspect=10, label='AO')
#ax2.view_init(elev=90, azim=-90)


plt.tight_layout()
plt.show()
import matplotlib.pyplot as plt
import numpy as np

# Create meshgrids for plotting
X_plot, T_plot = np.meshgrid(np.arange(nx) * dx, time)
Y_plot, T_plot_y = np.meshgrid(np.arange(ny) * dy, time)

# Convert AO_time data to NumPy arrays
AO_time_x_array = np.array(AO_time_x)
AO_time_y_array = np.array(AO_time_y)

# Create the figure with subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# First subplot: Contour AO vs x and t
contour1 = ax1.contourf(X_plot, T_plot, AO_time_x_array, levels=100, cmap='viridis')
ax1.set_xlabel('X-axis (km)')
ax1.set_ylabel('Time (hours)')
ax1.set_title('AO vs X and Time at y = 0.00375 km')
fig.colorbar(contour1, ax=ax1, label='AO')

# Second subplot: Contour AO vs y and t
contour2 = ax2.contourf(Y_plot, T_plot_y, AO_time_y_array, levels=100, cmap='viridis')
ax2.set_xlabel('Y-axis (km)')
ax2.set_ylabel('Time (hours)')
ax2.set_title('AO vs Y and Time at x = 0.95 km')
fig.colorbar(contour2, ax=ax2, label='AO')

plt.tight_layout()
plt.show()

# Plotting the velocities vs AO
plt.figure(figsize=(10, 6))
plt.scatter(AO_time,v_A_time, label='Class A')
plt.scatter(AO_time,v_B_time, label='Class B')
plt.scatter(AO_time,v_C_time, label='Class C')
plt.scatter (AO_time,v_D_time, label='Class D')
plt.ylabel('Velocity (km/hr)')
plt.xlabel('AO')
plt.title(f'Variation of velocity of vehicle classes at x = {x_loc} km, y = {y_loc} km with AO')
plt.grid(True)
plt.legend(fontsize=14, markerscale=2)
plt.show()

# Plotting the velocities vs AO
plt.figure(figsize=(10, 6))
plt.scatter(AO_time,uy_A_time, label='Class A')
plt.scatter(AO_time,uy_B_time, label='Class B')
plt.scatter(AO_time,uy_C_time, label='Class C')
plt.scatter (AO_time,uy_D_time, label='Class D')
plt.ylabel('Lateral velocity (km/hr)')
plt.xlabel('AO')
plt.title(f'Variation of lateral velocity of vehicle classes at x = {x_loc} km, y = {y_loc} km with AO')
plt.grid(True)
plt.legend(fontsize=14, markerscale=2)
plt.show()